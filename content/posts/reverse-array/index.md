+++
date = "2016-09-20T01:23:50+09:00"
title = "배열 뒤집기"
subtitle = "배타적 논리합(XOR)을 이용한 데이터 스왑"
tags = ["Algorithm"]
+++

# 문제
배열 안의 데이터 순서를 역순으로 바꾼다고 하자.  
`['a', 'b,' 'c', 'd']`와 같은 배열을 `['d', 'c', 'b', 'a']`와 같이 뒤집고 싶다는 것이다.  
C#, Python과 같이 사용자 친화적 언어들은 `.reverse()`하면 아주 손쉽게 배열을 뒤집을 수 있지만, C와 같은 언어에서는 한 번쯤 생각해 볼 수 있는 문제이다.

### 새로운 배열에 역순으로 복사
아마도 가장 단순 무식하게 떠올릴 수 있는 방법은, 똑같은 크기의 배열을 새로 만들어서 역순으로 데이터를 옮기는 것이다.
``` c
char new_array[SIZE];
for(i = 0; i < SIZE; ++i) {
    new_array[SIZE - 1 - i] = old_array[i];
}
```
간단히 옮기는 것 까지는 좋았는데, 배열 크기 만큼의 새로운 메모리가 필요하다니 낭비가 너무 심하다. 게다가 원본 저장소 `old_array`를 그대로 사용하고 싶다면 `memcpy`를 추가로 수행해줘야 한다.

뭐, 위 방법을 쓸리는 없고, 그냥 한 번 생각해보자는 것이니까 다음을 보자.

### 데이터 스왑을 이용
일반적으로 사용되는 가장 흔한 형태는, 아래와 같이 데이터 스왑을 이용해서 배열을 뒤집는 방법일 것이다.
``` c
char temp;
for(i = 0; i < SIZE / 2; ++i) {
    temp = array[i];
    array[i] = array[SIZE - 1 - i];
    array[SIZE - 1 - i] = temp;
}
```
배열의 양 끝에서부터 중간 지점까지 각각 차례로 한 칸씩 이동하며 데이터를 교환함으로써 배열의 순서를 뒤집고 있다. 데이터 스왑에는 임시 메모리를 이용한 전형적인 방법이 사용되었다.   
이 정도면 아주 작은 추가 메모리로 원본 저장소도 유지할 수 있고, 연산횟수도 반으로 줄었으니 더할 나위 없어 보인다.

그러나 모종의 변태들은, 새하얀 도화지의 까만 점 처럼 `temp`가 자꾸 눈에 밟히고 치명적인 오점인 것처럼 생각할지도 모른다. 요즘 컴퓨터 성능을 생각하면 전혀 쓸데없는 걱정이겠지만 말이다. 

# 배타적 논리합(XOR)을 이용한 데이터 스왑
비트 연산 XOR을 이용하면 여분의 메모리를 사용하지 않고도 데이터를 교환할 수 있다.

``` c
a ^= b;
b ^= a;
a ^= b;
```

|        | a       | z       |
| :----- | :-----: | :-----: |  
| init   | 1100001 | 1111010 |
| a ^= z | 0011011 | 1111010 |
| z ^= a | 1100001 | 0011011 |
| a ^= z | 1111010 | 1100001 |

메모리 내용 자체를 교환하는 방식이니까 어떤 데이터든 교환이 가능할까?  
비트 연산은 정수형 자료형만 가능하므로 일반적으로는 다른 자료형에 적용할 수 없지만, 약간의 트릭으로 실수형 자료형과 같은 다른 자료형에도 적용할 수 있다. 바로 포인터를 이용하는 것이다.
``` c++
float a = 1.0f, b = -1.0f;
*(reinterpret_cast<int *>(&a)) ^= *(reinterpret_cast<int *>(&b));
*(reinterpret_cast<int *>(&b)) ^= *(reinterpret_cast<int *>(&a));
*(reinterpret_cast<int *>(&a)) ^= *(reinterpret_cast<int *>(&b));  
```
비록 정수형 자료형의 크기와 동일한 크기를 가진 자료형만 해당되지만, 어엿하게 실수형 자료형에도 사용할 수 있다는 것이다.